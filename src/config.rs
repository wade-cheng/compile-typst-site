//! `compile-typst-site` project configuration, pulling from command-line arguments and a config file.

use anyhow::{Result, anyhow};
use derivative::Derivative;
use globset::{Glob, GlobSet, GlobSetBuilder};
use onlyargs_derive::OnlyArgs;
use serde::Deserialize;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::exit;

/// Build a site with typst.
#[derive(Clone, Debug, Eq, PartialEq, OnlyArgs)]
struct Args {
    /// Build and then watch for changes.
    watch: bool,
    /// Ignore initial full-site compilation step.
    ignore_initial: bool,
    /// Enable verbose logging.
    verbose: bool,
    /// Enable very verbose logging.
    trace: bool,
}

#[derive(Deserialize)]
struct ConfigFile {
    /// Array of globs to match for passthrough-copying.
    ///
    /// Example in the TOML config file: `passthrough_copy = ["*.css", "*.js", "assets/*"]
    passthrough_copy: Option<Vec<String>>,
    /// Command to run before a full rebuild.
    ///
    /// E.g., `passthrough_copy = ["echo", "rebuilding"]`.
    init: Option<Vec<String>>,
    /// Command to run to post-process HTML files generated by Typst.
    ///
    /// Must take in stdin and return via stdout.
    ///
    /// Example in the TOML config file: `post_processing_typ = ["python", "post_processing_script.py"]`.
    post_processing_typ: Option<Vec<String>>,
    /// Convert paths literally instead of magically tranforming to index.html.
    ///
    /// i.e., ./content.typ goes to ./content.html instead of defaulting to ./content/index.html.
    ///
    /// Example in the TOML config file: `literal_paths = true`
    literal_paths: Option<bool>,
}

/// Full config after taking in command line arguments, a configuration file, and other post-computations.
///
/// See [`Args`] and [`ConfigFile`] for documentation of fields.
#[derive(Derivative)]
#[derivative(Debug)]
pub struct Config {
    pub watch: bool,
    pub ignore_initial: bool,
    pub verbose: bool,
    pub trace: bool,
    pub passthrough_copy: Vec<String>,
    #[derivative(Debug = "ignore")]
    pub passthrough_copy_globs: GlobSet,
    pub init: Vec<String>,
    pub post_processing_typ: Vec<String>,
    pub literal_paths: bool,
    pub project_root: PathBuf,
    pub content_root: PathBuf,
    pub output_root: PathBuf,
    pub template_root: PathBuf,
}
const CONFIG_FNAME: &str = "compile-typst-site.toml";

impl Config {
    pub fn new() -> Self {
        Self::new_inner().unwrap_or_else(|err| {
            eprintln!("{}", err);
            exit(1)
        })
    }

    fn new_inner() -> Result<Self> {
        let content_root = PathBuf::from("src");
        let output_root = PathBuf::from("_site");
        let template_root = PathBuf::from("templates");

        let Args {
            watch,
            ignore_initial,
            verbose,
            trace,
        } = onlyargs::parse()?;

        let project_root = Self::get_project_root()?;

        let ConfigFile {
            passthrough_copy,
            init,
            post_processing_typ,
            literal_paths,
        } = Self::get_configfile(&project_root)?;
        let passthrough_copy = passthrough_copy.unwrap_or(vec![]);
        let init = init.unwrap_or(vec![]);
        let post_processing_typ = post_processing_typ.unwrap_or(vec![]);
        let literal_paths = literal_paths.unwrap_or(false);

        let passthrough_copy_globs =
            Self::compile_globs(&passthrough_copy, &project_root, &content_root)?;

        Ok(Self {
            watch,
            ignore_initial,
            verbose,
            trace,
            passthrough_copy,
            passthrough_copy_globs,
            init,
            post_processing_typ,
            literal_paths,
            project_root,
            content_root,
            output_root,
            template_root,
        })
    }

    fn get_project_root() -> Result<PathBuf> {
        let mut root = std::env::current_dir()?;

        loop {
            let candidate = root.join(CONFIG_FNAME);

            if candidate.exists() {
                return Ok(root);
            }

            if !root.pop() {
                return Err(anyhow!(
                    "Couldn't find a configuration file (looking for {CONFIG_FNAME}) in the current directory or any parent directories."
                ));
            }
        }
    }

    fn compile_globs(
        globs: &[String],
        project_root: &Path,
        content_root: &Path,
    ) -> Result<GlobSet> {
        let mut builder = GlobSetBuilder::new();

        for glob in globs {
            let glob = project_root
                .join(content_root)
                .join(glob)
                .to_str()
                .unwrap()
                .to_string();
            log::trace!("passthroughcopy glob is: {glob}");
            builder.add(Glob::new(&glob)?);
        }
        Ok(builder.build()?)
    }

    fn get_configfile(project_root: &Path) -> Result<ConfigFile> {
        let file = project_root.join(CONFIG_FNAME);
        let contents = fs::read_to_string(file)?;
        let config = toml::from_str(&contents)?;
        Ok(config)
    }
}
