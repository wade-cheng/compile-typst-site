use crate::error::Error;

use derivative::Derivative;
use globset::{Glob, GlobSet, GlobSetBuilder};
use onlyargs_derive::OnlyArgs;
use serde::Deserialize;
use std::path::{Path, PathBuf};
use std::process::exit;
use std::sync::LazyLock;
use std::{fs, io};

pub static CONFIG: LazyLock<Config> = LazyLock::new(Config::new);

/// Build a site with typst.
#[derive(Clone, Debug, Eq, PartialEq, OnlyArgs)]
struct Args {
    /// Build and then watch for changes.
    watch: bool,
    /// Ignore initial full-site compilation step.
    ignore_initial: bool,
    /// Enable verbose logging.
    verbose: bool,
    /// Enable very verbose logging.
    trace: bool,
}

#[derive(Deserialize)]
struct ConfigFile {
    /// Array of globs to match for passthrough-copying.
    ///
    /// E.g., `passthrough_copy = ["*.css", "*.js", "assets/*"]
    passthrough_copy: Option<Vec<String>>,
    /// Command to run before a full rebuild.
    ///
    /// E.g., `passthrough_copy = ["echo", "rebuilding"]`.
    init: Option<Vec<String>>,
    /// Command to run to post-process HTML files generated by Typst.
    ///
    /// Must take in stdin and return via stdout.
    ///
    /// E.g., `post_processing_typ = ["python", "post_processing_script.py"]`.
    post_processing_typ: Option<Vec<String>>,
}

/// Full config after taking in [`Args`], [`ConfigFile`], and other post-computations.
#[derive(Derivative)]
#[derivative(Debug)]
pub struct Config {
    /// Build and then watch for changes.
    pub watch: bool,
    /// Ignore initial full-site compilation step.
    pub ignore_initial: bool,
    /// Enable verbose logging.
    pub verbose: bool,
    /// Enable very verbose logging.
    pub trace: bool,
    /// Array of globs to match for passthrough-copying.
    ///
    /// Used for debugging, we should actually match with [`Self::passthrough_copy_globs`].
    ///
    /// E.g., `passthrough_copy = ["*.css", "*.js", "assets/*"]
    pub passthrough_copy: Vec<String>,
    #[derivative(Debug = "ignore")]
    pub passthrough_copy_globs: GlobSet,
    /// Command to run before a full rebuild.
    ///
    /// E.g., `passthrough_copy = ["echo", "rebuilding"]`.
    pub init: Vec<String>,
    /// Command to run to post-process HTML files generated by Typst.
    ///
    /// Must take in stdin and return via stdout.
    ///
    /// E.g., `post_processing_typ = ["python", "post_processing_script.py"]`.
    pub post_processing_typ: Vec<String>,
    pub project_root: PathBuf,
    pub content_root: PathBuf,
    pub output_root: PathBuf,
    pub template_root: PathBuf,
}
const CONFIG_FNAME: &str = "compile-typst-site.toml";

impl Config {
    pub fn new() -> Self {
        match Self::new_inner() {
            Ok(config) => config,
            Err(err) => {
                err.print_msg();
                exit(1)
            }
        }
    }

    fn new_inner() -> Result<Self, Error> {
        let content_root = PathBuf::from("src");
        let output_root = PathBuf::from("_site");
        let template_root = PathBuf::from("templates");

        let Args {
            watch,
            ignore_initial,
            verbose,
            trace,
        } = onlyargs::parse()?;

        let project_root = Self::get_project_root()?;

        let ConfigFile {
            passthrough_copy,
            init,
            post_processing_typ,
        } = Self::get_configfile(&project_root)?;
        let passthrough_copy = passthrough_copy.unwrap_or(vec![]);
        let init = init.unwrap_or(vec![]);
        let post_processing_typ = post_processing_typ.unwrap_or(vec![]);

        let passthrough_copy_globs =
            Self::compile_globs(&passthrough_copy, &project_root, &content_root)?;

        Ok(Self {
            watch,
            ignore_initial,
            verbose,
            trace,
            passthrough_copy,
            passthrough_copy_globs,
            init,
            post_processing_typ,
            project_root,
            content_root,
            output_root,
            template_root,
        })
    }

    fn get_project_root() -> Result<PathBuf, Error> {
        let mut root = std::env::current_dir()?;

        loop {
            let candidate = root.join(CONFIG_FNAME);

            if candidate.exists() {
                return Ok(root);
            }

            if !root.pop() {
                return Err(Error::Io(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!(
                        "Couldn't find a configuration file (looking for {CONFIG_FNAME}) in the current directory or any parent directories."
                    ),
                )));
            }
        }
    }

    fn compile_globs(
        globs: &[String],
        project_root: &Path,
        content_root: &Path,
    ) -> Result<GlobSet, Error> {
        let mut builder = GlobSetBuilder::new();

        for glob in globs {
            let glob = project_root
                .join(content_root)
                .join(glob)
                .to_str()
                .unwrap()
                .to_string();
            log::trace!("passthroughcopy glob is: {glob}");
            builder.add(Glob::new(&glob)?);
        }
        Ok(builder.build()?)
    }

    fn get_configfile(project_root: &Path) -> Result<ConfigFile, Error> {
        let file = project_root.join(CONFIG_FNAME);
        let contents = fs::read_to_string(file)?;
        let config = toml::from_str(&contents)?;
        Ok(config)
    }
}
