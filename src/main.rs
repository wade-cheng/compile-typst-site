use derivative::Derivative;
use error_iter::ErrorIter as _;
use globset::{Glob, GlobSet, GlobSetBuilder};
use log::LevelFilter;
use notify_debouncer_full;
use notify_debouncer_full::DebounceEventResult;
use notify_debouncer_full::notify::{EventKind, RecursiveMode};
use onlyargs::CliError;
use onlyargs_derive::OnlyArgs;
use onlyerror::Error;
use serde::Deserialize;
use simple_logger::SimpleLogger;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio, exit};
use std::sync::LazyLock;
use std::{fs, io};
use std::{sync::mpsc, time::Duration};
use walkdir::WalkDir;

/// Build a site with typst.
#[derive(Clone, Debug, Eq, PartialEq, OnlyArgs)]
struct Args {
    /// Build and then watch for changes.
    watch: bool,
    /// Ignore initial full-site compilation step.
    ignore_initial: bool,
    /// Enable verbose logging.
    verbose: bool,
    /// Enable very verbose logging.
    trace: bool,
}

#[derive(Deserialize)]
struct ConfigFile {
    /// Array of globs to match for passthrough-copying.
    ///
    /// E.g., `passthrough_copy = ["*.css", "*.js", "assets/*"]
    passthrough_copy: Option<Vec<String>>,
    /// Command to run before a full rebuild.
    ///
    /// E.g., `passthrough_copy = ["echo", "rebuilding"]`.
    init: Option<Vec<String>>,
    /// Command to run to post-process HTML files generated by Typst.
    ///
    /// Must take in stdin and return via stdout.
    ///
    /// E.g., `post_processing_typ = ["python", "post_processing_script.py"]`.
    post_processing_typ: Option<Vec<String>>,
}

/// Full config after taking in [`Args`], [`ConfigFile`], and other post-computations.
#[derive(Derivative)]
#[derivative(Debug)]
struct Config {
    /// Build and then watch for changes.
    watch: bool,
    /// Ignore initial full-site compilation step.
    ignore_initial: bool,
    /// Enable verbose logging.
    verbose: bool,
    /// Enable very verbose logging.
    trace: bool,
    /// Array of globs to match for passthrough-copying.
    ///
    /// Used for debugging, we should actually match with [`Self::passthrough_copy_globs`].
    ///
    /// E.g., `passthrough_copy = ["*.css", "*.js", "assets/*"]
    passthrough_copy: Vec<String>,
    #[derivative(Debug = "ignore")]
    passthrough_copy_globs: GlobSet,
    /// Command to run before a full rebuild.
    ///
    /// E.g., `passthrough_copy = ["echo", "rebuilding"]`.
    init: Vec<String>,
    /// Command to run to post-process HTML files generated by Typst.
    ///
    /// Must take in stdin and return via stdout.
    ///
    /// E.g., `post_processing_typ = ["python", "post_processing_script.py"]`.
    post_processing_typ: Vec<String>,
    project_root: PathBuf,
    content_root: PathBuf,
    output_root: PathBuf,
    template_root: PathBuf,
}
const CONFIG_FNAME: &str = "compile-typst-site.toml";

impl Config {
    fn new() -> Self {
        match Self::new_inner() {
            Ok(config) => config,
            Err(err) => {
                err.print_msg();
                exit(1)
            }
        }
    }

    fn new_inner() -> Result<Self, Error> {
        let content_root = PathBuf::from("src");
        let output_root = PathBuf::from("_site");
        let template_root = PathBuf::from("templates");

        let Args {
            watch,
            ignore_initial,
            verbose,
            trace,
        } = onlyargs::parse()?;

        let project_root = Self::get_project_root()?;

        let ConfigFile {
            passthrough_copy,
            init,
            post_processing_typ,
        } = Self::get_configfile(&project_root)?;
        let passthrough_copy = passthrough_copy.unwrap_or(vec![]);
        let init = init.unwrap_or(vec![]);
        let post_processing_typ = post_processing_typ.unwrap_or(vec![]);

        let passthrough_copy_globs =
            Self::compile_globs(&passthrough_copy, &project_root, &content_root)?;

        Ok(Self {
            watch,
            ignore_initial,
            verbose,
            trace,
            passthrough_copy,
            passthrough_copy_globs,
            init,
            post_processing_typ,
            project_root,
            content_root,
            output_root,
            template_root,
        })
    }

    fn get_project_root() -> Result<PathBuf, Error> {
        let mut root = std::env::current_dir()?;

        loop {
            let candidate = root.join(CONFIG_FNAME);

            if candidate.exists() {
                return Ok(root);
            }

            if !root.pop() {
                return Err(Error::Io(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!(
                        "Couldn't find a configuration file (looking for {CONFIG_FNAME}) in the current directory or any parent directories."
                    ),
                )));
            }
        }
    }

    fn compile_globs(
        globs: &[String],
        project_root: &Path,
        content_root: &Path,
    ) -> Result<GlobSet, Error> {
        let mut builder = GlobSetBuilder::new();

        for glob in globs {
            let glob = project_root
                .join(content_root)
                .join(glob)
                .to_str()
                .unwrap()
                .to_string();
            log::trace!("passthroughcopy glob is: {glob}");
            builder.add(Glob::new(&glob)?);
        }
        Ok(builder.build()?)
    }

    fn get_configfile(project_root: &Path) -> Result<ConfigFile, Error> {
        let file = project_root.join(CONFIG_FNAME);
        let contents = fs::read_to_string(file)?;
        let config = toml::from_str(&contents)?;
        Ok(config)
    }
}

#[derive(Debug, Error)]
enum Error {
    /// Argument parsing error.
    Cli(#[from] CliError),
    /// I/O error.
    Io(#[from] std::io::Error),
    /// notify crate error.
    Notify(#[from] notify_debouncer_full::notify::Error),
    /// toml crate error.
    Toml(#[from] toml::de::Error),
    /// globset crate error.
    Globset(#[from] globset::Error),
}

impl Error {
    fn print_msg(&self) {
        eprintln!("Error: {self}");
        for source in self.sources().skip(1) {
            eprintln!("  Caused by: {source}");
        }

        if matches!(self, Error::Cli(_)) {
            eprintln!("Try {} --help", std::env::args().next().unwrap());
        }
    }
}

static CONFIG: LazyLock<Config> = LazyLock::new(Config::new);

fn compile_from_scratch() -> Result<(), Error> {
    log::info!("running init command");
    if CONFIG.init.len() > 0 {
        Command::new(&CONFIG.init[0])
            .args(&CONFIG.init[1..])
            .spawn()
            .unwrap()
            .wait()
            .unwrap();
        log::trace!("finished init");
    }

    log::info!("starting compilation");
    compile_batch(
        WalkDir::new(CONFIG.project_root.join(&CONFIG.content_root))
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|entry| entry.metadata().unwrap().is_file())
            .map(|entry| entry.path().to_path_buf()),
    )?;

    log::info!("compiled project from scratch");

    Ok(())
}

fn compile_single(path: &PathBuf) -> Result<(), Error> {
    log::trace!("here1 compiling {}", path.to_str().unwrap());
    if CONFIG.passthrough_copy_globs.is_match(path) {
        log::trace!("here2");
        let path_in_src = path
            .strip_prefix(CONFIG.project_root.join(&CONFIG.content_root))
            .unwrap();
        let rel_path = path_in_src.parent().unwrap();
        let parent_dir_in_dst = CONFIG.project_root.join(&CONFIG.output_root).join(rel_path);
        let file_in_dst = parent_dir_in_dst.join(path.file_name().unwrap());

        fs::create_dir_all(CONFIG.project_root.join(&CONFIG.output_root).join(rel_path))?;
        fs::copy(path, &file_in_dst)?;

        log::trace!(
            "passthroughcopied {} to {}",
            path.to_str().unwrap(),
            file_in_dst.to_str().unwrap()
        );
    } else if path.extension().is_some() && path.extension().unwrap() == "typ" {
        log::trace!("here3");

        if let Ok(_) = path.strip_prefix(CONFIG.project_root.join(&CONFIG.template_root)) {
            compile_from_scratch()?;
            // need to be careful of infinite recursion, compile_everything calls us (compile)
            // should be fine because this code path should only trigger when compiling
            // on the template root.
            //
            // ... what if someone puts their template code in their src folder?
        } else if let Ok(path_in_src) =
            path.strip_prefix(CONFIG.project_root.join(&CONFIG.content_root))
        {
            let rel_path = path_in_src.parent().unwrap();
            let parent_dir_in_dst = CONFIG.project_root.join(&CONFIG.output_root).join(rel_path);
            let mut file_in_dst = parent_dir_in_dst.join(path.file_name().unwrap());
            file_in_dst.set_extension("html");

            fs::create_dir_all(CONFIG.project_root.join(&CONFIG.output_root).join(rel_path))
                .unwrap();
            let mut child = Command::new("typst")
                .arg("c")
                .arg(path)
                .arg("-") // to stdout
                .arg("--features")
                .arg("html")
                .arg("--format")
                .arg("html")
                .arg("--root")
                .arg(&*CONFIG.project_root)
                .stdout(Stdio::piped())
                .spawn()
                .unwrap();

            if CONFIG.post_processing_typ.len() > 0 {
                child = Command::new(&CONFIG.post_processing_typ[0])
                    .args(&CONFIG.post_processing_typ[1..])
                    .stdin(child.stdout.unwrap())
                    .stdout(Stdio::piped())
                    .spawn()
                    .unwrap();
            }

            let output = child.wait_with_output().unwrap();

            fs::write(&file_in_dst, output.stdout).unwrap();

            log::trace!(
                "typfile compiled {} to {}",
                path.to_str().unwrap(),
                file_in_dst.to_str().unwrap()
            );
        }
    }

    Ok(())
}

fn compile_batch(paths: impl Iterator<Item = PathBuf>) -> Result<(), Error> {
    std::thread::scope(|s| {
        for path in paths {
            s.spawn(move || {
                compile_single(&path).unwrap_or_else(|err| err.print_msg());
                log::debug!("compiled {}", path.to_str().unwrap());
            });
        }
    });

    Ok(())
}

fn run() -> Result<(), Error> {
    SimpleLogger::new()
        .without_timestamps()
        .with_level(LevelFilter::Off)
        .with_module_level(
            "compile_typst_site",
            if CONFIG.trace {
                LevelFilter::Trace
            } else if CONFIG.verbose {
                LevelFilter::Debug
            } else {
                LevelFilter::Info
            },
        )
        .init()
        .unwrap();

    log::trace!("loaded configuration: {:#?}", &*CONFIG);

    if CONFIG.ignore_initial {
        log::info!("ignoring initial compile from scratch");
    } else {
        compile_from_scratch()?;
    }

    if CONFIG.watch {
        let (tx, rx) = mpsc::channel::<DebounceEventResult>();

        let mut debouncer =
            notify_debouncer_full::new_debouncer(Duration::from_millis(200), None, tx)?;

        debouncer.watch(
            &*CONFIG.project_root.join(&CONFIG.content_root),
            RecursiveMode::Recursive,
        )?;
        debouncer.watch(
            &*CONFIG.project_root.join(&CONFIG.template_root),
            RecursiveMode::Recursive,
        )?;
        for res in rx {
            match res {
                Ok(events) => {
                    for event in events {
                        if let EventKind::Create(_) | EventKind::Modify(_) = event.kind {
                            compile_batch(event.event.paths.into_iter())?;
                            // TODO: figure out howo to debug-level log watched compilations
                        }
                    }
                }
                Err(errors) => errors.iter().for_each(|error| eprintln!("{error:?}")),
            }
        }
    }

    Ok(())
}

fn main() {
    run().unwrap_or_else(|err| err.print_msg());
}
